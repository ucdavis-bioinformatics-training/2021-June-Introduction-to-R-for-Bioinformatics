---
output:
    html_document
---

<script src="../assets/js/quiz.js"></script>

```{css echo=FALSE}
.colsel {
background-color: lightyellow;
}

pre, code {
  white-space:pre !important;
  overflow-x:scroll auto
}
```


```{r echo=FALSE}
library(knitr)
colFmt = function(x,color){
  outputFormat = opts_knit$get("rmarkdown.pandoc.to")
  if(outputFormat == 'latex')
    paste("\\textcolor{",color,"}{",x,"}",sep="")
  else if(outputFormat == 'html')
    paste("<font color='",color,"'>",x,"</font>",sep="")
  else
    x
}
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(class.source = "colsel", echo=TRUE)
```

```{r echo=F, include=FALSE}
library(dplyr)
library(kableExtra)
```

---


Start an R session
====================
**BEFORE YOU BEGIN, YOU NEED TO START AN R SESSION**

You can run this tutorial in an IDE (like Rstudio) on your laptop.

**NOTE: Below, the text in the yellow boxes is code to input (by typing it or copy/pasting) into your R session, the text in the white boxes is the expected output.**

---


Import data into R
===================

We are going to import a metadata spreadsheet into R and then learn about basic R concepts by dissecting the data. There are two main way to import a regular spreadsheet file into R. 

##### The R base function read.table() is a general funciton that can be used to read a file in table format. The data will be imported as a "data frame", which we will discuss below.

```{r}
# You can read files directly from the internet.
metadata <- read.table(file="https://github.com/ucdavis-bioinformatics-training/2021-June-Introduction-to-R-for-Bioinformatics/raw/master/R/glioma_metadata.tsv", sep="\t", header=T)

# To read a local file. If you have downloaded the glioma_metadata.tsv file to your local machine, you may use the following command to read it in, by providing the full path for the file location. The way to specify the full path is the same as taught in the command line session.
download.file("https://github.com/ucdavis-bioinformatics-training/2021-June-Introduction-to-R-for-Bioinformatics/raw/master/R/glioma_metadata.tsv", "./glioma_metadata.tsv")
metadata <- read.table(file="./glioma_metadata.tsv", sep="\t", header=T)

```

Let's break down this line:

metadata <- read.table(file="https://github.com/ucdavis-bioinformatics-training/2021-June-Introduction-to-R-for-Bioinformatics/raw/master/R/glioma_metadata.tsv", sep="\t", header=T)

First, we have a variable name, **metadata**. A variable is a name used to store data. This is a variable that we created, so it could be named anything (e.g. var1, hellothere, jsksj23jjj), however, it is best to name it something that makes sense in terms of what you are doing. Since we are reading in metadata, calling the variable 'metadata' makes sense. In R, variable names can only have letters, numbers, underscores and periods. The variable names cannot start with a number and cannot have any spaces in them.

Next, we have the **<-** (arrow) operator. This symbol is basically an assignment operator, meaning it is taking the output of "read.table" and putting it into the metadata variable. You can also use the equals sign (**=**) instead of the arrow in almost all cases.

**read.table** is a **function**. A function is a command that is invoked (called) to do some calculation, manipulation, reformatting, etc. on data. It usually returns some value. If a function is called without assigning the return value to a variable, then R prints the return value to the screen. 

A function typically has **parameters**, which are inputs to the function. These parameters are specified within the parentheses after the function name. In our case, the parameters are **file**, **sep**, and **header**. And the values for those parameters are the value that comes after the equals sign for each of them. I.e., the value for "file" is "https://...", the value for "sep" is "\t", and the value for "header" is "T". Notice that the file and sep values are in quotes... this is because when you are specifying characters (known as strings), you have to put them in quotes. The "\t" is the way you indicate the **tab** character. I.e., the separator between the fields for each line in this file is the tab character. Finally, the **T** value for header means **TRUE**, a boolean (true/false) value. I.e., this file has a header line which should be used as the names of each of the columns.

Functions can have many parameters, but you only have to specify the required ones and those you are changing from the defaults. In order to see the full description and parameter list of a function, type a **?** followed by the function name. In Rstudio, you can also just search in the "Help" tab.

```{r}
?read.table
```

##### Depending on the format of the file, several variants of read.table() are available to make reading a file easier.

* read.csv(): for reading "comma separated value" files (.csv).

* read.csv2(): variant used in countries that use a comma "," as decimal point and a semicolon ";" as field separators.

* read.delim(): for reading "tab separated value" files (".txt"). By default, point(".") is used as decimal point.

* read.delim2(): for reading "tab separated value" files (".txt"). By default, comma (",") is used as decimal point.

<br>

It is also possible to export data to a csv file.

write.csv()

write.csv2()


Data Frames
------------

Let's take a look at the data:

```{r}
metadata
```

When you just type in the name of a variable and press Enter, it prints the current value of the variable. To get just the first few lines, use the **head** function:

```{r}
head(metadata)
```

This gives us the first 6 lines of the data frame and once it reaches the edge of the screen, it prints the next columns beneath the previous columns. Notice that the numbering of the rows on the left hand side is 1 through 6 for all the columns. So, what are we looking at? This is a **data frame**. It is a structure (also known as an object) that holds multiple types of data. In this case, we have character data, numeric data, date data, boolean data, etc. Note that the column names are taken from the first line of the file, but any non-alphabet (and period) characters are changed to periods.

There are multiple ways to access different parts of a data frame. One way is using indices. For example:

```{r}
metadata[1,2]
```

This gives us the value in the first row, 2nd column. We can also get all the values in a row (or column) by not specifying one of the indices:

```{r}
metadata[,3]
```

This gives us the values for every row, column 3.

```{r}
metadata[4,]
```

This gives us the values for row 4, every column. Another way to access the columns is by using the **$** operator:

```{r}
metadata$Breed
```


Basic data types
-----------------

There are 3 basic data types in R: logical (boolean), numeric, and character.

```{r}
status <- TRUE
status
```

```{r}
max.weight <- 200
max.weight
```

```{r}
sample <- "Glioma_1"
sample
```


You can usee **class* to find out the type of a variable:

```{r}
class(status)
```

```{r}
class(max.weight)
```

```{r}
class(sample)
```


You can also convert one type to another:

```{r}
as.character(max.weight)
```

```{r}
as.numeric(status)
```

And add certain types together:

```{r}
status + max.weight
```


##### A logical *TRUE* is converted to integer 1 and a logical *FALSE* is converted to integer 0.

<br>

## Quiz 1

<div id="quiz1" class="quiz"></div>
<button id="submit1">Submit Quiz</button>
<div id="results1" class="output"></div>
<script>
quizContainer1 = document.getElementById('quiz1');
resultsContainer1 = document.getElementById('results1');
submitButton1 = document.getElementById('submit1');

myQuestions1 = [
  {
    question: "Create a variable a and set it to 3, and a variable b set to 'gene'. What is a + b?",
    answers: {
      a: "a",
      b: "3",
      c: "Gives an error",
      d: "4"
    },
    correctAnswer: "c"
  },
  {
    question: "Create another variable c set to FALSE. What is a + c?",
    answers: {
      a: "Gives an error",
      b: "3",
      c: "a",
      d: "4"
    },
    correctAnswer: "b"
  },
  {
    question: "What is 1 + TRUE?",
    answers: {
      a: "2",
      b: "1",
      c: "TRUE",
      d: "FALSE"
    },
    correctAnswer: "a"
  }
];

buildQuiz(myQuestions1, quizContainer1);
submitButton1.addEventListener('click', function() {showResults(myQuestions1, quizContainer1, resultsContainer1);});
</script>

---


Topic 2. Basic data structures in R
====================================================

```{r echo=FALSE}

kable(data.frame(Homogeneous=c("Atomic vector", "Matrix", "Array"), Heterogeneous=c("List", "Data frame", ""), row.names=c("1d", "2d", "Nd"), stringsAsFactors=F), align='c') %>% kable_styling(bootstrap_options="striped", full_width=F, position="center", font_size=18)
```
<br>


#### Atomic vectors: an atomic vector is a combination of multiple values(numeric, character or logical) in the same object. An atomic vector is created using the function c().

```{r}
gene_names <- c("ESR1", "p53", "PI3K", "BRCA1", "EGFR")
gene_names

gene_expression <- c(0, 100, 50, 200, 80)
gene_expression
```
<br>

##### One can give names to the elements of an atomic vector.
```{r}
# assign names to a vector by specifying them
names(gene_expression) <- c("ESR1", "p53", "PI3K", "BRCA1", "EGFR")
gene_expression

# assign names to a vector using another vector
names(gene_expression) <- gene_names
gene_expression
```
<br>

##### Or One may create a vector with named elements from scratch.
```{r}
gene_expression <- c(ESR1=0, p53=100, PI3K=50, BRCA1=200, EGFR=80)
gene_expression
```
<br>

##### To find out the length of a vector:
```{r}
length(gene_expression)
```

   
##### `r colFmt("NOTE: a vector can only hold elements of the same type. If there are a mixture of data types, they will be coerced according to the coersion rule mentioned earlier in this documentation.", 'red')`  

<br>

#### Factors: a factor is a special vector. It stores categorical data, which are important in statistical modeling and can only take on a limited number of pre-defined values. The function factor() can be used to create a factor.

```{r}
disease_stage <- factor(c("Stage1", "Stage2", "Stage2", "Stage3", "Stage1", "Stage4"))
disease_stage
```
<br>

##### In R, categories of the data are stored as factor levels. The function levels() can be used to access the factor levels.

```{r}
levels(disease_stage)
```

##### A function to compactly display the internal structure of an R object is str(). Please use str() to display the internal structure of the object we just created *disease_stage*. It shows that _disease_stage_ is a factor with four levels: "Stage1", "Stage2", "Stage3", etc... The integer numbers after the colon shows that these levels are encoded under the hood by integer values: the first level is 1, the second level is 2, and so on. Basically, when _factor_ function is called, R first scan through the vector to determine how many different categories there are, then it converts the character vector to a vector of integer values, with each integer value labeled with a category.


```{r}
str(disease_stage)
```


##### By default, R infers the factor levels by ordering the unique elements in a factor alphanumerically. One may specifically define the factor levels at the creation of the factor.


```{r}
disease_stage <- factor(c("Stage1", "Stage2", "Stage2", "Stage3", "Stage1", "Stage4"), levels=c("Stage2", "Stage1", "Stage3", "Stage4"))
# The encoding for levels are different from above.
str(disease_stage)
```

If you want to know the number of individuals at each levels, there are two functions: _summary_ and _table_.

```{r}
summary(disease_stage)
```

```{r}
table(disease_stage)
```


## Quiz 2

<div id="quiz2" class="quiz"></div>
<button id="submit2">Submit Quiz</button>
<div id="results2" class="output"></div>
<script>
quizContainer2 = document.getElementById('quiz2');
resultsContainer2 = document.getElementById('results2');
submitButton2 = document.getElementById('submit2');

myQuestions2 = [
  {
    question: "Try to add a new 7th element to the disease_stage factor. When the new element does not match any of the levels of the factor, what will happen?",
    answers: {
      a: "A new level will be added to the factor",
      b: "A new element will be added to the factor that is an NA",
      c: "Nothing happens",
      d: "Gives a warning"
    },
    correctAnswer: "b"
  },
  {
    question: "You can type a '?' and then a function name to get help for that function. What does the 'relevel' function do?",
    answers: {
      a: "Sorts the factors",
      b: "Overwrites the factor levels",
      c: "Adds a new level to the factors",
      d: "Reorders the levels"
    },
    correctAnswer: "d"
  },
  {
    question: "What would the levels be for the following vector as a factor:<br>c('a','C','d','b',1,'!')",
    answers: {
      a: "a b C d 1 !",
      b: "! 1 a b d C",
      c: "1 a b C d !",
      d: "! 1 a b C d"
    },
    correctAnswer: "d"
  }
];

buildQuiz(myQuestions2, quizContainer2);
submitButton2.addEventListener('click', function() {showResults(myQuestions2, quizContainer2, resultsContainer2);});
</script>


<br>

---

#### Matrices: A matrix is like an Excel sheet containing multiple rows and columns. It is used to combine vectors of the same type.

```{r}
col1 <- c(1,3,8,9)
col2 <- c(2,18,27,10)
col3 <- c(8,37,267,19)

my_matrix <- cbind(col1, col2, col3)
my_matrix

```

##### One other way to create a matrix is to use *matrix()* function.

```{r}
nums <- c(col1, col2, col3)
nums
matrix(nums, ncol=2)
```

```{r}
rownames(my_matrix) <- c("row1", "row2", "row3", "row4")
my_matrix

t(my_matrix)
```

##### To find out the dimension of a matrix:

```{r}
ncol(my_matrix)
nrow(my_matrix)
dim(my_matrix)
```


##### Calculations with numeric matrices.

```{r}
my_matrix * 3
log10(my_matrix)
```

Total of each row.
```{r}
rowSums(my_matrix)
```

Total of each column.
```{r}
colSums(my_matrix)
```

##### There is a data structure _Array_ in R, that holds multi-dimensional (d > 2) data and is a generalized version of a matrix. *Matrix* is used much more commonly than *Array*, therefore we are not going to talk about *Array* here.


#### Data frames: a data frame is like a matrix but can have columns with different types (numeric, character, logical).

##### A data frame can be created using the function data.frame().

```{r}
# creating a data frame using pre-defined vectors
patients_name=c("Patient1", "Patient2", "Patient3", "Patient4", "Patient5", "Patient6")
Family_history=c("Y", "N", "Y", "N", "Y", "Y")
patients_age=c(31, 40, 39, 50, 45, 65)
meta.data <- data.frame(patients_name=patients_name, disease_stage=disease_stage, Family_history=Family_history, patients_age=patients_age)
meta.data
```

###### To check whether a data is a data frame, use the function is.data.frame().

```{r}
is.data.frame(meta.data)
```

```{r}
is.data.frame(my_matrix)
```

###### One can convert a matrix object to a data frame using the function as.data.frame().

```{r}
class(my_matrix)
```

```{r}
my_data <- as.data.frame(my_matrix)
class(my_data)
```

##### A data frame can be transposed in the similar way as a matrix. However, the result of transposing a data frame might not be a data frame anymore.

```{r}
my_data
```

```{r}
t(my_data)
```

##### A data frame can be extended.

```{r}
# add a column that has the information on harmful mutations in BRCA1/BRCA2 genes for each patient.
meta.data
meta.data$BRCA <- c("YES", "NO", "YES", "YES", "YES", "NO")
meta.data
```

##### A data frame can also be extended using the functions cbind() and rbind(), for adding columns and rows respectively. When using cbind(), the number of values in the new column must match the number of rows in the data frame. When using rbind(), the two data frames must have the same variables/columns.

```{r}
# add a column that has the information on the racial information for each patient.
cbind(meta.data, Race=c("AJ", "AS", "AA", "NE", "NE", "AS"))
# rbind can be used to add more rows to a data frame.
rbind(meta.data, data.frame(patients_name="Patient7", disease_stage="S4", Family_history="Y", patients_age=48, BRCA="YES"))
```

##### One may use the function *merge* to merge two data frames horizontally, based on one or more common key variables.

```{r}
expression.data <- data.frame(patients_name=c("Patient3", "Patient4", "Patient5", "Patient1", "Patient2", "Patient6"), EGFR=c(10, 472, 103784, 1782, 187, 18289), TP53=c(16493, 72, 8193, 1849, 173894, 1482))
expression.data
md2 <- merge(meta.data, expression.data, by="patients_name")
md2
```
<br>

## Quiz 3

<div id="quiz3" class="quiz"></div>
<button id="submit3">Submit Quiz</button>
<div id="results3" class="output"></div>
<script>
quizContainer3 = document.getElementById('quiz3');
resultsContainer3 = document.getElementById('results3');
submitButton3 = document.getElementById('submit3');

myQuestions3 = [
  {
    question: "Find a function to add up the EGFR column in md2. What is the total?",
    answers: {
      a: "124524",
      b: "124526",
      c: "124528",
      d: "124530"
    },
    correctAnswer: "a"
  },
  {
    question: "Multiply my_matrix by itself, sum the columns, and then use the 'mean' function to find the mean:",
    answers: {
      a: "24799.33",
      b: "24797.33",
      c: "24798.33",
      d: "24796.33"
    },
    correctAnswer: "c"
  }
];

buildQuiz(myQuestions3, quizContainer3);
submitButton3.addEventListener('click', function() {showResults(myQuestions3, quizContainer3, resultsContainer3);});
</script>

## CHALLENGE
Using the **mtcars** built-in dataset (Type "mtcars" to see it), add a row that has the averages of each column and name it "Averages". Now, add a column to mtcars called "hp.gt.100" that is TRUE or FALSE depending on whether the horsepower (hp) for that car is greater than 100 or not.

---

#### Lists: a list is an ordered collection of objects, which can be any type of R objects (vectors, matrices, data frames, even lists).

##### A list is constructed using the function list().

```{r}
my_list <- list(1:5, "a", c(TRUE, FALSE, FALSE), c(3.2, 103.0, 82.3))
my_list
str(my_list)
```

##### One could construct a list by giving names to elements.

```{r}
my_list <- list(Ranking=1:5, ID="a", Test=c(TRUE, FALSE, FALSE), Score=c(3.2, 103.0, 82.3))

# display the names of elements in the list using the function *names*, or *str*. Compare the output of *str* with the above results to see the difference.
names(my_list)
str(my_list)
```

```{r}
# number of elements in the list
length(my_list)
```

#### Subsetting data

#### Subsetting allows one to access the piece of data of interest. When combinded with assignment, subsetting can modify selected pieces of data. The operators that can be used to subset data are: [, $, and [[.

##### First, we are going to talk about subsetting data using [, which is the most commonly used operator. We will start by looking at vectors and talk about four ways to subset a vector.

* `r colFmt("**Positive integers** return elements at the specified positions", 'purple')`

```{r}
# first to recall what are stored in gene_names
gene_names
# obtain the first and the third elements
gene_names[c(1,3)]
```

R uses 1 based indexing, meaning the first element is at the position 1, not at position 0.

* `r colFmt("**Negative integers** omit elements at the specified positions", 'purple')`

```{r}
gene_names[-c(1,3)]
```

One may not mixed positive and negative integers in one single subset operation.

```{r error=TRUE}
# The following command will produce an error.
gene_names[c(-1, 2)]
```

* `r colFmt("**Logical vectors** select elements where the corresponding logical value is TRUE", 'purple')`, This is very useful because one may write the expression that creates the logical vector.

```{r}
gene_names[c(TRUE, FALSE, TRUE, FALSE, FALSE)]
```

Recall that we have created one vector called *gene_expression*. Let's assume that *gene_expression* stores the expression values correspond to the genes in *gene_names*. Then we may subset the genes based on expression values.

```{r}
gene_expression

gene_names[gene_expression > 50]
```

If the logical vector is shorter in length than the data vector that we want to subset, then it will be recycled to be the same length as the data vector.

```{r}
gene_names[c(TRUE, FALSE)]
```

If the logical vector has "NA" in it, the corresponding value will be "NA" in the output. "NA" in R is a symbol for missing value.

```{r}
gene_names[c(TRUE, NA, FALSE, TRUE, NA)]
```

* `r colFmt("**Character vectors** return elements with matching names, when the vector is named.", 'purple')`

```{r}
gene_expression
gene_expression[c("ESR1", "p53")]
```

* `r colFmt("**Nothing** returns the original vector", 'purple')`, This is more useful for matrices, data frames than for vectors.

```{r}
gene_names[]
```

<br>

##### Subsetting a list works in the same way as subsetting an atomic vector. Using [ will always return a list.

```{r}
my_list[1]
```
<br>

##### Subsetting a matrix can be done by simply generalizing the one dimension subsetting: one may supply a one dimension index for each dimension of the matrix. `r colFmt("Blank/Nothing subsetting is now useful in keeping all rows or all columns.", 'red')`


```{r}
my_matrix[c(TRUE, FALSE), ]
```
<br>

##### Subsetting a data frame can be done similarly as subsetting a matrix. In addition, one may supply only one 1-dimensional index to subset a data frame. In this case, R will treat the data frame as a list with each column is an element in the list.

```{r}
# recall a data frame created from above: *meta.data*
meta.data
# subset the data frame similarly to a matrix
meta.data[c(TRUE, FALSE, FALSE, TRUE),]

# subset the data frame using one vector
meta.data[c("patients_age", "disease_stage")]
```

<br>

#### Subsetting operators: **[[** and **$**

##### **[[** is similar to **[**, except that it returns the content of the element.

```{r}
# recall my_list
my_list
# comparing [[ with [ in subsetting a list
my_list[[1]]
my_list[1]
```

`r colFmt("[[ is very useful when working with a list. Because when [ is applied to a list, it always returns a list. While [[ returns the contents of the list. [[ can only extrac/return one element, so it only accept one integer/string as input.", 'red')`

Because data frames are implemented as lists of columns, one may use [[ to extract a column from data frames.

```{r}
meta.data[["disease_stage"]]
```


<br>

##### **$** is a shorthand for **[[** combined with character subsetting.

```{r}
# subsetting a list using $ 
my_list$Score
# subsetting a data frame using
meta.data$disease_stage
```

<br>

##### Simplifying vs. preserving subsetting

We have seen some examples of simplying vs. preserving subsetting, for example:

```{r}
# simplifying subsetting
my_list[[1]]
# preserving subsetting
my_list[1]
```

Basically, simplying subsetting returns the simplest possible data structure that can represent the output. While preserving subsetting keeps the structure of the output as the same as the input. In the above example, [[ simplifies the output to a vector, while [ keeps the output as a list.

Because the syntax of carrying out simplifying and preserving subsetting differs depending on the data structure, the table below provides the information for the most basic data structure.

```{r, echo=FALSE}
kable(data.frame(Simplifying=c("x[[1]]", "x[[1]]", "x[1:3, drop=T]", "x[, 1] or x[[1]]"), Preserving=c("x[1]", "x[1]", "x[1:3]", "x[, 1, drop=F] or x[1]"), row.names=c("Vector", "List", "Factor", "Data frame"), stringsAsFactors=F), align='c') %>% kable_styling(bootstrap_options="striped", full_width=F, position="left")
```

## CHALLENGES

Using the built-in dataset **iris**, first subset the dataframe keeping only those rows where the sepal length is greater than 6. Then find the total number for each Species in that subset.

Using **iris**, remove the width columns and then create a new dataframe with the Species and the sum of the rows.


---

Topic 3. Import and export data in R
====================================================

##### R base function read.table() is a general funciton that can be used to read a file in table format. The data will be imported as a data frame.

```{r}
# There is a very convenient way to read files from the internet.
data1 <- read.table(file="https://github.com/ucdavis-bioinformatics-training/courses/raw/master/Intro2R/raw_counts.txt", sep="\t", header=T, stringsAsFactors=F)

# To read a local file. If you have downloaded the raw_counts.txt file to your local machine, you may use the following command to read it in, by providing the full path for the file location. The way to specify the full path is the same as taught in the command line session.
download.file("https://github.com/ucdavis-bioinformatics-training/courses/raw/master/Intro2R/raw_counts.txt", "./raw_counts.txt")
data1 <- read.table(file="./raw_counts.txt", sep="\t", header=T, stringsAsFactors=F)

```

To check what type of object *data1* is in and take a look at the beginning part of the data.
```{r}
is.data.frame(data1)
head(data1)
```


##### Depending on the format of the file, several variants of read.table() are available to make reading a file easier.

* read.csv(): for reading "comma separated value" files (.csv).

* read.csv2(): variant used in countries that use a comma "," as decimal point and a semicolon ";" as field separators.

* read.delim(): for reading "tab separated value" files (".txt"). By default, point(".") is used as decimal point.

* read.delim2(): for reading "tab separated value" files (".txt"). By default, comma (",") is used as decimal point.

<br>

```{r}
# We are going to read a file over the internet by providing the url of the file.
data2 <- read.csv(file="https://github.com/ucdavis-bioinformatics-training/courses/raw/master/Intro2R/raw_counts.csv", stringsAsFactors=F)

# To look at the file:
head(data2)
```

<br>

##### R base function write.table() can be used to export data to a file.

```{r}
# To write to a file called "output.txt" in your current working directory.
write.table(data2[1:20,], file="output.txt", sep="\t", quote=F, row.names=T, col.names=T)
```

It is also possible to export data to a csv file.

write.csv()

write.csv2()


## Quiz 4

<div id="quiz4" class="quiz"></div>
<button id="submit4">Submit Quiz</button>
<div id="results4" class="output"></div>
<script>
quizContainer4 = document.getElementById('quiz4');
resultsContainer4 = document.getElementById('results4');
submitButton4 = document.getElementById('submit4');

myQuestions4 = [
  {
    question: "Using my_list, multiply the Ranking by the Score and find the mean in one command. What is the output?",
    answers: {
      a: "196.78 without a warning",
      b: "196.78 with a warning",
      c: "210.54 without a warning",
      d: "210.54 with a warning"
    },
    correctAnswer: "b"
  },
  {
    question: "Which of the following code will NOT get a result?",
    answers: {
      a: "gene_expression$ESR1",
      b: "gene_expression['ESR1']",
      c: "gene_expression[c(1,2,3,4)]",
      d: "gene_expression[1:2]"
    },
    correctAnswer: "a"
  },
  {
    question: "When you run this code:<br><br>my_list[1] * my_list[[1]]<br><br>you get an error. Why?",
    answers: {
      a: "Because you can't multiply a list and a number together.",
      b: "Because you can't multiply a list with itself.",
      c: "Because you can't multiply a list with another list.",
      d: "All of the above."
    },
    correctAnswer: "d"
  },
  {
    question: "Using data1 and the 'max' function, find the maximum value across columns C92, I563, and I861:",
    answers: {
      a: "69853",
      b: "112754",
      c: "88122",
      d: "66890"
    },
    correctAnswer: "a"
  }
];

buildQuiz(myQuestions4, quizContainer4);
submitButton4.addEventListener('click', function() {showResults(myQuestions4, quizContainer4, resultsContainer4);});
</script>

---

Topic 4. R markdown and R notebooks
====================================================

Markdown is a system that allow easy incorporation of annotations/comments together with computing code. Both the raw source of markdown file and the rendered output are easy to read. R markdown allows both interactive mode with R and producing a reproducible document. An R notebook is an R markdown document with code chunks that can be executed independently and interactively, with output visible immediately beneath the input. In RStudio, by default, all R markdown documents are run in R notebook mode. Under the R notebook mode, when executing a chunk, the code is sent to the console to be run one line at a time. This allows execution to stop if a line raises an error.

<br>

In RStudio, creating an R notebook can be done by going to the menu command ** File -> New File -> R Notebook **.

An example of an R notebook looks like:


![](./notebook.png)


The way to run the R code inside the code chunk is to use the green arrow located at the top right corner of each of the code chunk, or use ** Ctrl + Shift + Enter ** on Windows, or ** Cmd + Shift + Enter ** on Mac to run the current code chunk. To run each individual code line, one uses ** Ctrl + Enter ** on Windows, or ** Cmd + Enter ** on Mac.

To render R notebook to html/pdf/word documents can be done using the **Preview** menu.

---

Topic 5. Functions in R
====================================================
#### Invoking a function by its name, followed by the parenthesis and zero or more arguments.

```{r}
# to find out the current working directory
getwd()

# to set a different working directory, use setwd
#setwd("/Users/jli/Desktop")

# to list all objects in the environment
ls()

# to create a vector from 2 to 3, using increment of 0.1
seq(2, 3, by=0.1)

# to create a vector with repeated elements
rep(1:3, times=3)
rep(1:3, each=3)

# to get help information on a function in R: ?function.name
?seq
?sort
?rep

```  

##### `r colFmt("One useful function to find out information on an R object: str(). It compactly display the internal structure of an R object.", 'red')`  


```{r}
str(data2)
```


#### Conditional structure

Decision making is important in programming. This can be achieved using an **if...else** statement.

The basic structure of an *if...else* statement is 

**if (condition statement){**

	**some operation**

**}**


Two examples of *if...else* statement

```{r}

Temperature <- 30

if (Temperature < 32) {
  print("Very cold")
}

```

```{r}
# recall gene_expression, we are going to design a *if...else* statement to decide treatment plans based on gene expression.

if (gene_expression["ESR1"] > 0) {
  print("Treatment plan 1")
} else if (gene_expression["BRCA1"] > 0) {
  print("Treatment plan 2")
} else if (gene_expression["p53"] > 0) {
  print("Treatment plan 3")
} else {
  print("Treatment plan 4")
}

```


#### Loop structure

In programming, it is common that one has to do one set of specific operation on a sequence of elements. In this case, *for* loop is very useful to achieve the goal.

The basic structure of *for* loop is:

**for (value in sequence){**

  **some operation**

**}**


For example, we would like to calculate the sum of a row for every row in the matrix we created earlier. We are going to use a *for* loop to do it.


```{r}
for (i in 1:dim(my_matrix)[1]) {
  out <- sum(my_matrix[i, ])
  print(out)
}
```

There is a **while** loop in R similarly as in command line or any other programming language. The basic structure of a *while* loop is:

**while (condition){**

  **some operation**

**}**


Here is the same row sum calculation using a while loop:

```{r}
while (i <= dim(my_matrix)[1]){
  out <- sum(my_matrix[i,])
  print(out)
  i <- i + 1
}
```


<br>

---

#### A few useful functions: apply(), lapply(), sapply(), and tapply() to replace for loop

##### apply() takes an array or matrix as input and outputs a vector, array or list.

```{r}
# recall my_matrix
my_matrix
# check the usage of apply() function
?apply()
# calculate sums for each row
apply(my_matrix, MARGIN=1, sum)
```


##### lapply() takes a list, vector or data frame as input and outputs a list.


```{r}
?lapply()

# generate some random data matrix
data3 <- as.data.frame(matrix(rnorm(49), ncol=7), stringsAsFactors=F)
dim(data3)

# calculate the sum for each row
lapply(1:dim(data3)[1], function(x){sum(data3[x,])})

# comparing the results to apply() results
apply(data3, MARGIN=1, sum)

# calculate log10 of the sum of each row
lapply(1:dim(data3)[1], function(x){log10(sum(data3[x,]))})
```

##### The function sapply() works like function lapply(), but tries to simplify the output to the simplest data structure possible. As a matter of fact, sapply() is a "wrapper" function for lapply(). By default, it returns a vector.

```{r}
# To check the syntax of using sapply():
?sapply()

sapply(1:dim(data3)[1], function(x){log10(sum(data3[x,]))})
```

##### If the "simplify" parameter is turned off, sapply() will produced exactly the same results as lapply(), in the form of a list. By default, "simplify" is turned on.
```{r}
sapply(1:dim(data3)[1], function(x){log10(sum(data3[x,]))}, simplify=FALSE)
```

#### The function tapply() applys a function to each subset of a vector based on a second vector of factors.

```{r}
?tapply()

# Let's use Fisher's Iris data to demonstrate the usage of tapply().
# First, load the Iris dataset
data(iris)

# Take a look at what the data includes
head(iris)

# Generate a summary of the sepal lengths for each iris species.
tapply(iris$Sepal.Length, iris$Species, summary)
```

#### Write one's own functions

Even though there are a lot of R packages available, there are always situations where one might have to write one's own function to accomplish some very specific goals. Functions are defined by code with a specific format:

```{r}
function.name <- function(arg1=arg1, arg2, ...){
	var <- sin(arg1) + sin(arg2)  # carry out tasks
	var / 2
}
```

Here, we are going to write a function to calculate the area of a triangle given the lengths of three sides.

```{r}
my.area <- function(side1=side1, side2=side2, side3=side3){
	circumference <- (side1 + side2 + side3) / 2
	area <- sqrt(circumference * (circumference - side1) * (circumference - side2) * (circumference - side3))
	return(area)
}

# let's carry out some test
my.area(side1=3, side2=4, side3=5)
```

<br>

## Quiz 5

<div id="quiz5" class="quiz"></div>
<button id="submit5">Submit Quiz</button>
<div id="results5" class="output"></div>
<script>
quizContainer5 = document.getElementById('quiz5');
resultsContainer5 = document.getElementById('results5');
submitButton5 = document.getElementById('submit5');

myQuestions5 = [
  {
    question: "Find the area of a triangle with sides 32, 22, and 40:",
    answers: {
      a: "352.3445",
      b: "351.2478",
      c: "350.2112",
      d: "354.7849"
    },
    correctAnswer: "b"
  },
  {
    question: "Use the 'sd' function along with sapply to get the standard deviation for every row in data1. Then find the maximum of those values:",
    answers: {
      a: "26106.23",
      b: "26107.23",
      c: "26108.23",
      d: "26105.23"
    },
    correctAnswer: "a"
  },
  {
    question: "Now, using the apply function find only those rows whose standard deviation is greater than 20000. What is the row name?",
    answers: {
      a: "AT1G21310",
      b: "AT3G09260",
      c: "AT1G67090",
      d: "AT3G53420"
    },
    correctAnswer: "b"
  }
];

buildQuiz(myQuestions5, quizContainer5);
submitButton5.addEventListener('click', function() {showResults(myQuestions5, quizContainer5, resultsContainer5);});
</script>

---


## CHALLENGE

Write a function to calculate min-max normalization for a single row. Here is the formula:

<img src="min_max.png" width="200"/>

Then use apply to normalize every row of data2. You might want to take a small piece of data2 to test it with, e.g. the first 3 rows and first 3 columns.

## HARD CHALLENGE

Now take your normalized data and write a function to find the log2-fold change (i.e. the log of the ratio of normalized counts) between any two samples across all genes. Then use one of the apply functions to calculate log2-fold change across ALL samples, given one sample. Finally, use a for loop to find the pair-wise log2-fold changes for every pair of samples.


Topic 6. Basic statistics in R
====================================================

```{r echo=FALSE, results= 'asis'}
library(knitr)
kable(data.frame(Description=c("Mean", "Standard deviation", "Variance", "Minimum", "Maximum", "Median", "Range of values: minimum and maximum", "Sample quantiles", "Generic function", "Interquartile range"), R_function=c("mean()", "sd()", "var()", "min()", "max()", "median()", "range()", "quantile()", "summary()", "IQR()"), stringsAsFactors=F), align='c') %>% kable_styling(bootstrap_options=c("striped", "hover", "responsive"), full_width=F, position="center")
```

Calculate the mean expression for each sample.

```{r}
apply(data3, 2, mean)
```

Calculate the range of expression for each sample.

```{r}
apply(data3, 2, range)
```

Calculate the quantiles of each samples.

```{r}
apply(data3, 2, quantile)
```


---

Topic 7. Simple data visulization in R
====================================================

Scatter plot and line plot can be produced using the function plot().

```{r}
x <- c(1:50)
y <- 1 + sqrt(x)/2
plot(x,y)

plot(x,y, type="l")

# plot both the points and lines
## first plot points
plot(x,y)
lines(x,y, type="l")
## lines() can only be used to add information to a graph, while it cannot produce a graph on its own.

```


boxplot() can be used to summarize data.

```{r}
boxplot(data3, xlab="Sample ID", ylab="Raw Counts")
```

```{r}
x <- rnorm(1000)
boxplot(x)
```

hist() can be used to create histograms of data.
```{r}
hist(x)

# use user defined break points
hist(x, breaks=seq(range(x)[1]-1, range(x)[2]+1, by=0.5))
```

```{r}
# clear plotting device/area
dev.off()
```


---

Topic 8. Install packages in R
====================================================

##### Starting from Bioconductor version 3.8, the installation of packages is recommended to use BiocManager.

```{r eval=FALSE}
if (!requireNamespace("BiocManager"))
	install.packages("BiocManager")
## install core packages
BiocManager::install()
## install specific packages
BiocManager::install(c("devtools", "tidyverse","bsseq","DSS"))
```

* Bioconductor has a repository and release schedule that differ from R (Bioconductor has a ‘devel’ branch to which new packages and updates are introduced, and a stable ‘release’ branch emitted once every 6 months to which bug fixes but not new features are introduced). This mismatch causes that the version detected by install.packages() is sometimes not the most recent 'release'.

* A consequence of the distinct 'devel' branch is that install.packages() sometimes points only to the 'release' repository, while users might want to have access to the leading-edge features in the develop version.

* An indirect consequence of Bioconductor's structured release is that packages generally have more extensive dependences with one another.


##### `r colFmt("It is always recommended to update to the most current version of R and Bioconductor. If it is not possible and R < 3.5.0, please use the legacy approach to install Bioconductor packages", 'orange')`   

```{r eval=FALSE}
source("http://bioconductor.org/biocLite.R")
## install core packages
biocLite()
## install specific packages
biocLite(c("devtools", "tidyverse","bsseq","DSS"))
```
   
##### The R function install.packages() can be used to install packages that are not part of Bioconductor.

```{r eval=FALSE}
install.packages("ggplot2", repos="http://cran.us.r-project.org")
install.packages(c("kableExtra","knitr","dplyr"))
```

##### Install from source of github.
```{r eval=FALSE}
library(devtools)
install_github("stephenturner/qqman")
```



---

Topic 9. Save data in R session
====================================================

#### To save history in R session

```{r}
#savehistory(file="Oct08.history")

#loadhistory(file="Oct08.history")
```

#### To save objects in R session

```{r}
save(list=c("x", "data"), file="Oct08.RData")

#load("Oct08.RData")
```

---

`r colFmt("Final challenge", 'blue')`
====================================================

Working with an R notebook, load the Iris data as we did earlier in this documentation, generate a table that lists the median of each measurement (Sepal.Length, Sepal.Width, Petal.Length, Petal.Width) for each species. Then generate a plot based on the result. Finally produce an html report with the table and the plot. Below serves as an example output.


```{r echo=FALSE, message=FALSE, warning=FALSE, error=FALSE}
library(lattice)
library(reshape2)
tmp <- sapply(1:4, function(x){tapply(iris[,x], iris[[5]], median)})
colnames(tmp) <- colnames(iris)[1:4]
nms <- colnames(tmp)
kable(data.frame(tmp, stringsAsFactors=F), align='c') %>% kable_styling(bootstrap_options=c("striped", "hover", "responsive"), full_width=F, position="center")
# scatter plot of mean measurement
species <- as.vector(levels(iris$Species))
x <- c(1, 2, 3, 4)
plot(x, tmp["setosa",], pch=20, col='red', ylim=c(0, max(tmp)), xaxt="n", xlab="Measurement type", ylab="Measurement results", cex.lab=1.0)
points(x, tmp["virginica",], pch=20, col='orange')
points(x, tmp["versicolor",], pch=20, col='blue')
axis(1, at=x, labels=nms, las=2, cex.axis=0.7)
text(c(1.5,1.5,1.5), c(0, 0.7, 1.4), labels=species, col=c("red", "blue", "orange"), cex=1.5)
# scatter plot of measurement by species
dd <- melt(iris)
xyplot(value ~ variable | Species, data=dd, scales=list(x=list(rot=90)), xlab="Measurements", ylab="Values")
# boxplot by group
cols <- c("red", "blue", "orange")
boxplot(value ~ Species + variable, data=dd, col = cols, xaxt="n", yaxt="n", xlab="Measurement Type", ylab="Values")
axis(side=1, labels=FALSE)
axis(side=2, las=2)
text(x=1:12, y=par("usr")[3] - 0.85, labels=c("", "Sepal.Length", "", "", "Sepal.Width", "", "", "Petal.Length", "", "", "Petal.Width", ""), xpd=NA, srt=35, cex=1)
legend("topright", fill=cols, legend=levels(dd$Species))
```


#### `r colFmt("Hints: ", 'red')`

* In order to output a nice looking table in the final report, one may consider the R package kableExtra https://github.com/haozhu233/kableExtra. One may also check out the documentation at https://cran.r-project.org/web/packages/htmlTable/vignettes/

* Figure 1 can be produced using base R functions: plot(), points(), axis(), text().

* Figure 2 can be produced using functions in R package lattice https://cran.r-project.org/web/packages/lattice/index.html

* Figure 3 can be produced using function boxplot()

#### **Solution:**


```{r echo=FALSE, message=FALSE, warnings=FALSE}
library(xfun)
xfun::embed_file('solution.Rmd')
```


<br>


